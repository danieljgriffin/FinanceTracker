<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Portfolio - Net Worth Tracker</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <style>
        body {
            background: linear-gradient(135deg, #0c0c0c 0%, #1a1a1a 100%);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        
        .trading-card {
            background: rgba(20, 20, 20, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
        }
        
        .bottom-nav {
            background: rgba(10, 10, 10, 0.95);
            backdrop-filter: blur(20px);
            border-top: 1px solid rgba(255, 255, 255, 0.05);
        }
        
        .nav-icon {
            transition: all 0.2s ease;
        }
        
        .nav-icon.active {
            color: #00d4ff !important;
        }

        /* Privacy mode styles */
        .privacy-blur {
            filter: blur(8px);
            transition: filter 0.3s ease;
        }
        

    </style>
</head>
<body class="bg-black text-white min-h-screen">
    
    <!-- Main Content -->
    <div class="pb-24">
        <!-- Header -->
        <div class="flex items-center justify-between p-4">
            <div>
                <h1 class="text-white text-lg font-semibold">Portfolio</h1>
            </div>
        </div>
        
        <!-- Portfolio Value -->
        <div class="px-4 mb-6">
            <div class="mb-2 flex items-center justify-between">
                <span id="portfolioValue" class="text-3xl font-bold text-white">£{{ "{:,.2f}".format(current_net_worth) }}</span>
                <button onclick="togglePrivacy()" class="ml-3 p-2 rounded-full bg-gray-800/50 hover:bg-gray-700/50 transition-colors">
                    <i id="privacyIcon" class="fas fa-eye text-gray-400 text-lg"></i>
                </button>
            </div>
            
            <!-- Last Updated Info -->
            <div class="mb-4">
                <span class="text-gray-400 text-xs">Last updated {{ last_updated.strftime('%d/%m/%Y %H:%M') if last_updated else 'Never' }}</span>
            </div>
            
            <!-- Monthly and Yearly Stats -->
            <div class="flex space-x-8 mb-2">
                <div>
                    <span class="text-gray-400 text-xs uppercase tracking-wide">MONTHLY</span>
                    <div class="flex items-center space-x-1">
                        <span class="text-{% if mom_change >= 0 %}green{% else %}red{% endif %}-400 font-semibold text-sm">
                            {% if mom_change >= 0 %}+{% endif %}£{{ "{:,.0f}".format(mom_amount_change) }}
                        </span>
                        <span class="text-{% if mom_change >= 0 %}green{% else %}red{% endif %}-400 text-xs">
                            ({% if mom_change >= 0 %}+{% endif %}{{ "{:.1f}".format(mom_change) }}%)
                        </span>
                    </div>
                </div>
                <div>
                    <span class="text-gray-400 text-xs uppercase tracking-wide">YEARLY</span>
                    <div class="flex items-center space-x-1">
                        <span class="text-{% if yoy_amount_change >= 0 %}green{% else %}red{% endif %}-400 font-semibold text-sm">
                            {% if yoy_amount_change >= 0 %}+{% endif %}£{{ "{:,.0f}".format(yoy_amount_change) }}
                        </span>
                        <span class="text-{% if yoy_amount_change >= 0 %}green{% else %}red{% endif %}-400 text-xs">
                            ({% if yoy_amount_change >= 0 %}+{% endif %}{{ "{:.1f}".format(yoy_percentage_change) }}%)
                        </span>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Full Width Chart -->
        <div class="mb-6">
            <div id="chartContainer" class="h-64 w-full relative">
                <svg viewBox="0 0 400 256" class="w-full h-full" id="portfolioChart">
                    <!-- Chart elements will be dynamically updated -->
                </svg>
                
                <!-- Interactive overlay for touch/hover - aligned with chart data points -->
                <div id="chartOverlay" class="absolute inset-0 bg-transparent" 
                     ontouchstart="handleChartTouch(event)" 
                     ontouchmove="handleChartTouch(event)"
                     ontouchend="hideTooltip()"></div>
                
                <!-- Touch indicator dot -->
                <div id="touchIndicator" class="absolute pointer-events-none opacity-0 transition-opacity duration-200">
                    <div class="w-3 h-3 bg-white rounded-full border-2 border-blue-400"></div>
                </div>
                
                <!-- Mobile value tooltip -->
                <div id="mobileTooltip" class="absolute pointer-events-none opacity-0 transition-opacity duration-200 bg-black bg-opacity-90 text-white text-sm px-3 py-2 rounded-lg backdrop-blur-sm border border-white border-opacity-20">
                    <div id="mobileTooltipValue" class="font-semibold"></div>
                    <div id="mobileTooltipDate" class="text-gray-300 text-xs mt-1"></div>
                </div>
            </div>
            
            <!-- Time Range Options -->
            <div class="flex justify-center space-x-4 mt-3 px-4 text-xs">
                <span class="text-white font-semibold cursor-pointer" onclick="updateChart('1d')">1D</span>
                <span class="text-gray-400 cursor-pointer hover:text-white transition-colors" onclick="updateChart('1w')">1W</span>
                <span class="text-gray-400 cursor-pointer hover:text-white transition-colors" onclick="updateChart('3m')">3M</span>
                <span class="text-gray-400 cursor-pointer hover:text-white transition-colors" onclick="updateChart('1y')">1Y</span>
                <span class="text-gray-400 cursor-pointer hover:text-white transition-colors" onclick="updateChart('2023')">2023</span>
                <span class="text-gray-400 cursor-pointer hover:text-white transition-colors" onclick="updateChart('2024')">2024</span>
                <span class="text-gray-400 cursor-pointer hover:text-white transition-colors" onclick="updateChart('2025')">2025</span>
                <span class="text-gray-400 cursor-pointer hover:text-white transition-colors" onclick="updateChart('MAX')" id="activeRange">MAX</span>
            </div>
        </div>
        
        <!-- Section Tabs -->
        <div class="px-4 mb-4">
            <div class="flex">
                <button class="flex-1 py-3 text-center text-white border-b-2 border-blue-400">
                    <span class="font-medium">Net Worth Breakdown</span>
                </button>
            </div>
        </div>
        

        
        <!-- Investment List -->
        <div class="px-4 space-y-3">
            {% for platform, amount in platform_allocations.items() %}
            <div class="flex items-center justify-between py-3 breakdown-item">
                <div class="flex items-center space-x-3">
                    <!-- Platform Icon -->
                    <div class="w-10 h-10 rounded-lg flex items-center justify-center" 
                         style="background-color: {{ platform_colors[platform] }}">
                        <!-- Keep the colored icon background only -->
                    </div>
                    
                    <!-- Platform Info -->
                    <div>
                        <div class="text-white font-medium">{{ platform }}</div>
                        <div class="text-gray-400 text-sm">{{ "{:.1f}".format(platform_percentages.get(platform, 0)) }}% of portfolio</div>
                    </div>
                </div>
                
                <!-- Value and Change -->
                <div class="text-right">
                    <div class="text-white font-semibold breakdown-value">£{{ "{:,.2f}".format(amount) }}</div>
                    {% set platform_change = platform_monthly_changes.get(platform, {'amount': 0, 'percent': 0}) %}
                    <div class="text-{% if platform_change.amount >= 0 %}green{% else %}red{% endif %}-400 text-sm">
                        {% if platform_change.amount >= 0 %}+{% endif %}£{{ "{:,.0f}".format(platform_change.amount) }}
                        ({% if platform_change.percent >= 0 %}+{% endif %}{{ "{:.2f}".format(platform_change.percent) }}%)
                    </div>
                </div>
            </div>
            {% endfor %}
        </div>
    </div>
    
    <!-- Bottom Navigation -->
    <div class="fixed bottom-0 left-0 right-0 bottom-nav" style="padding-bottom: env(safe-area-inset-bottom, 16px);">
        <div class="flex justify-around items-center py-4 pb-3">
            <a href="#" class="flex flex-col items-center py-2 nav-icon active">
                <i class="fas fa-home text-lg mb-1"></i>
                <span class="text-xs">Home</span>
            </a>
            <a href="#" class="flex flex-col items-center py-2 nav-icon text-gray-400">
                <i class="fas fa-briefcase text-lg mb-1"></i>
                <span class="text-xs">Investments</span>
            </a>
            <a href="#" class="flex flex-col items-center py-2 nav-icon text-gray-400">
                <i class="fas fa-calendar-alt text-lg mb-1"></i>
                <span class="text-xs">Tracker</span>
            </a>
            <a href="#" class="flex flex-col items-center py-2 nav-icon text-gray-400">
                <i class="fas fa-bullseye text-lg mb-1"></i>
                <span class="text-xs">Goals</span>
            </a>
            <a href="#" class="flex flex-col items-center py-2 nav-icon text-gray-400">
                <i class="fas fa-chart-bar text-lg mb-1"></i>
                <span class="text-xs">Breakdown</span>
            </a>
        </div>
    </div>
    
    <script>
        // Use real chart data from server
        const chartData = {{ chart_data | tojson | safe }};

        let currentRange = 'MAX';
        let currentChartData = null;
        let isInteracting = false;

        function updateChart(range) {
            console.log('Mobile updateChart called with range:', range, 'current:', currentRange);
            if (range === currentRange) return;
            
            // Update active range styling first
            document.querySelectorAll('[onclick^="updateChart"]').forEach(el => {
                el.className = 'text-gray-400 cursor-pointer hover:text-white transition-colors';
            });
            
            // Find and highlight the selected range
            const allRangeElements = document.querySelectorAll('[onclick^="updateChart"]');
            allRangeElements.forEach(el => {
                const onclick = el.getAttribute('onclick');
                const elRange = onclick.match(/updateChart\('(.+?)'\)/)?.[1];
                if (elRange === range) {
                    el.className = 'text-white font-semibold cursor-pointer';
                }
            });
            
            currentRange = range;
            
            // Map mobile filters to API filters
            let apiFilter;
            if (range.toLowerCase() === 'max') {
                apiFilter = 'all-years';
            } else if (range === '1d') {
                apiFilter = '24h';
            } else if (range === '1w') {
                apiFilter = 'week';
            } else if (range === '3m') {
                apiFilter = '3months';
            } else if (range === '1y') {
                apiFilter = 'year';
            } else {
                apiFilter = range; // 2023, 2024, 2025
            }
            
            const apiUrl = `/api/realtime-chart-data?filter=${apiFilter}`;
            console.log('Fetching mobile chart data from:', apiUrl, 'for range:', range);
            
            fetch(apiUrl)
                .then(response => response.json())
                .then(data => {
                    console.log('Mobile chart data received:', data);
                    updateMobileChartDisplay(data, range);
                })
                .catch(error => {
                    console.error('Error fetching mobile chart data:', error);
                    // Fallback to static data
                    const svg = document.getElementById('portfolioChart');
                    const staticData = chartData[range];
                    if (staticData) {
                        updateMobileChartDisplay(staticData, range);
                    }
                });
        }
        
        function updateMobileChartDisplay(data, range) {
            const svg = document.getElementById('portfolioChart');
            
            console.log('Updating mobile chart display for range:', range);
            console.log('Chart data:', data);
            
            // Handle both API data format and static data format
            let lineData, yLabels, xLabels, hasCurrentValue;
            
            if (data.labels && data.values) {
                // API format - convert to SVG chart format
                console.log('Converting API data to SVG chart format');
                console.log('Data labels:', data.labels);
                console.log('Data values:', data.values);
                
                // Generate SVG chart elements from API data (balanced padding for labels)
                const chartWidth = 380;
                const chartHeight = 200;
                const padding = 20;
                const rightPadding = 35; // Balanced space for right-side labels
                const plotWidth = chartWidth - padding - rightPadding;
                const plotHeight = chartHeight - padding * 2;
                
                // Find min and max values for scaling
                const minValue = Math.min(...data.values);
                const maxValue = Math.max(...data.values);
                const valueRange = maxValue - minValue;
                
                // Generate chart points
                const points = data.values.map((value, index) => {
                    const x = padding + (index / (data.values.length - 1)) * plotWidth;
                    const y = padding + plotHeight - ((value - minValue) / valueRange) * plotHeight;
                    return `${x},${y}`;
                }).join(' ');
                
                // Generate data point circles
                const dataPoints = data.values.map((value, index) => {
                    const x = padding + (index / (data.values.length - 1)) * plotWidth;
                    const y = padding + plotHeight - ((value - minValue) / valueRange) * plotHeight;
                    return `<circle cx="${x}" cy="${y}" r="3" fill="#00d4ff" stroke="#1a1a1a" stroke-width="1"/>`;
                }).join('');
                
                // Generate Y-axis labels (properly positioned on right side)
                const yLabels = [];
                for (let i = 0; i <= 4; i++) {
                    const value = minValue + (valueRange * i / 4);
                    const y = padding + plotHeight - (i / 4) * plotHeight;
                    yLabels.push(`<text x="370" y="${y + 4}" font-size="11" fill="#9ca3af" text-anchor="start">£${(value / 1000).toFixed(0)}k</text>`);
                }
                
                // Generate X-axis labels - show all months for yearly data, otherwise smart spacing
                const xLabels = [];
                if (range === '2023' || range === '2024' || range === '2025') {
                    // Show all months for yearly views
                    for (let i = 0; i < data.labels.length; i++) {
                        const x = padding + (i / (data.labels.length - 1)) * plotWidth;
                        // Extract month from label (e.g., "Jan 25" -> "Jan")
                        const monthLabel = data.labels[i].split(' ')[0];
                        xLabels.push(`<text x="${x}" y="240" font-size="9" fill="#6b7280" text-anchor="middle">${monthLabel}</text>`);
                    }
                } else {
                    // Smart spacing for other views
                    const labelStep = Math.ceil(data.labels.length / 6); // Show ~6 labels max
                    for (let i = 0; i < data.labels.length; i += labelStep) {
                        const x = padding + (i / (data.labels.length - 1)) * plotWidth;
                        xLabels.push(`<text x="${x}" y="240" font-size="10" fill="#6b7280" text-anchor="middle">${data.labels[i]}</text>`);
                    }
                }
                
                // Mark current value point only for live/current data (not historical years)
                let currentPointMarkup = '';
                if (range !== '2023' && range !== '2024') {
                    // Only show "current" indicator for live data ranges
                    const lastIndex = data.values.length - 1;
                    const lastX = padding + (lastIndex / (data.values.length - 1)) * plotWidth;
                    const lastY = padding + plotHeight - ((data.values[lastIndex] - minValue) / valueRange) * plotHeight;
                    currentPointMarkup = `<circle cx="${lastX}" cy="${lastY}" r="5" fill="#00d4ff" stroke="#ffffff" stroke-width="2"/>`;
                }
                
                svg.innerHTML = `
                    <polyline fill="none" stroke="#00d4ff" stroke-width="2" points="${points}"/>
                    ${dataPoints}
                    ${currentPointMarkup}
                    ${yLabels.join('')}
                    ${xLabels.join('')}
                `;
                
                // Store chart data for potential interactions
                currentRange = range;
                currentChartData = {
                    values: data.values,
                    labels: data.labels,
                    points: points,
                    hasCurrentValue: true
                };
                
                console.log('Mobile SVG chart generated successfully');
                
                // Store chart data for touch interactions
                window.mobileChartData = {
                    values: data.values,
                    labels: data.labels,
                    dataPoints: data.values.map((value, index) => {
                        const x = padding + (index / (data.values.length - 1)) * plotWidth;
                        const y = padding + plotHeight - ((value - minValue) / valueRange) * plotHeight;
                        return { x, y, value, label: data.labels[index] };
                    }),
                    chartBounds: {
                        left: padding,
                        right: padding + plotWidth,
                        top: padding,
                        bottom: padding + plotHeight
                    }
                };
                
                return;
            } else if (data.line) {
                // Static format - use directly
                lineData = data.line;
                yLabels = data.yLabels;
                xLabels = data.xLabels;
                hasCurrentValue = data.hasCurrentValue;
            } else {
                console.warn('No chart data for range:', range);
                svg.innerHTML = '<text x="200" y="120" text-anchor="middle" fill="#666" font-size="14">No data available</text>';
                return;
            }
            
            // Update chart  
            const chartHasCurrentValue = hasCurrentValue || false;
            const linePoints = lineData.split(' ');
            const lastPoint = linePoints[linePoints.length - 1];
            
            // Create dots for each data point
            const dataPoints = linePoints.map(point => {
                const [x, y] = point.split(',');
                return `<circle cx="${x}" cy="${y}" r="3" fill="#00d4ff" stroke="#1a1a1a" stroke-width="1"/>`;
            }).join('');
            
            // Mark current value point differently if it exists
            const currentPointMarkup = chartHasCurrentValue && lastPoint ? 
                `<circle cx="${lastPoint.split(',')[0]}" cy="${lastPoint.split(',')[1]}" r="5" fill="#00d4ff" stroke="#ffffff" stroke-width="2"/>` : '';
            
            svg.innerHTML = `
                <polyline fill="none" stroke="#00d4ff" stroke-width="2" points="${lineData}"/>
                ${dataPoints}
                ${currentPointMarkup}
                ${yLabels.map(label => 
                    `<text x="385" y="${label.y}" font-size="11" fill="#9ca3af" text-anchor="end">${label.text}</text>`
                ).join('')}
                ${xLabels.map(label => 
                    `<text x="${label.x}" y="240" font-size="10" fill="${label.text.includes('*') ? '#00d4ff' : '#6b7280'}" text-anchor="middle">${label.text}</text>`
                ).join('')}
            `;
            
            currentRange = range;
            currentChartData = {
                line: lineData,
                yLabels: yLabels,
                xLabels: xLabels,
                hasCurrentValue: chartHasCurrentValue
            };
            
            // Store actual data points for precise hover detection
            const points = lineData.split(' ').map((point, index) => {
                const [x, y] = point.split(',').map(Number);
                return {
                    x: x,
                    y: y,
                    label: xLabels[index]?.text || '',
                    index: index
                };
            });
            currentChartData.dataPoints = points;
            
            // setupChartInteraction(); // Disabled - no hover interactions
        }

        // Mobile touch interaction functions
        function handleChartTouch(event) {
            if (!window.mobileChartData) return;
            
            event.preventDefault();
            const touch = event.touches[0] || event.changedTouches[0];
            if (!touch) return;
            
            const chartContainer = document.querySelector('.relative');
            const rect = chartContainer.getBoundingClientRect();
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            
            // Find closest data point
            let closestPoint = null;
            let minDistance = Infinity;
            
            window.mobileChartData.dataPoints.forEach(point => {
                const distance = Math.sqrt(Math.pow(x - point.x, 2) + Math.pow(y - point.y, 2));
                if (distance < minDistance && distance < 30) { // 30px touch tolerance
                    minDistance = distance;
                    closestPoint = point;
                }
            });
            
            if (closestPoint) {
                showMobileTooltip(closestPoint, x, y);
            } else {
                hideTooltip();
            }
        }
        
        function showMobileTooltip(point, touchX, touchY) {
            const indicator = document.getElementById('touchIndicator');
            const tooltip = document.getElementById('mobileTooltip');
            const valueEl = document.getElementById('mobileTooltipValue');
            const dateEl = document.getElementById('mobileTooltipDate');
            
            // Position touch indicator
            indicator.style.left = (point.x - 6) + 'px';
            indicator.style.top = (point.y - 6) + 'px';
            indicator.style.opacity = '1';
            
            // Update tooltip content
            valueEl.textContent = `£${point.value.toLocaleString('en-GB', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
            dateEl.textContent = point.label;
            
            // Position tooltip (above touch point, adjust if too close to edges)
            let tooltipX = touchX - 50; // Center tooltip roughly
            let tooltipY = touchY - 70; // Position above touch
            
            // Keep tooltip within bounds
            if (tooltipX < 10) tooltipX = 10;
            if (tooltipX > 280) tooltipX = 280;
            if (tooltipY < 10) tooltipY = touchY + 20; // Move below if too high
            
            tooltip.style.left = tooltipX + 'px';
            tooltip.style.top = tooltipY + 'px';
            tooltip.style.opacity = '1';
            
            // Auto-hide after 3 seconds
            clearTimeout(window.tooltipHideTimer);
            window.tooltipHideTimer = setTimeout(hideTooltip, 3000);
        }
        
        function hideTooltip() {
            const indicator = document.getElementById('touchIndicator');
            const tooltip = document.getElementById('mobileTooltip');
            
            indicator.style.opacity = '0';
            tooltip.style.opacity = '0';
            
            clearTimeout(window.tooltipHideTimer);
        }

        // Initialize chart on page load with MAX view
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Chart data:', chartData);
            
            // Force 1D view to be active on load (like desktop)
            currentRange = '';
            updateChart('1d');
            
            // Touch behaviors disabled - no chart interactions
            
            // Start auto-refresh for live updates (portfolio values)
            startAutoRefresh();
            
            // Auto-refresh chart data every 30 seconds for real-time updates
            startChartAutoRefresh();
        });

        // Privacy toggle functionality
        let privacyMode = false;

        function togglePrivacy() {
            privacyMode = !privacyMode;
            const icon = document.getElementById('privacyIcon');
            const portfolioValue = document.getElementById('portfolioValue');
            const chartContainer = document.getElementById('chartContainer');
            const breakdownValues = document.querySelectorAll('.breakdown-value');

            if (privacyMode) {
                // Enable privacy mode
                icon.className = 'fas fa-eye-slash text-blue-400 text-lg';
                portfolioValue.classList.add('privacy-blur');
                chartContainer.classList.add('privacy-blur');
                breakdownValues.forEach(el => el.classList.add('privacy-blur'));
            } else {
                // Disable privacy mode
                icon.className = 'fas fa-eye text-gray-400 text-lg';
                portfolioValue.classList.remove('privacy-blur');
                chartContainer.classList.remove('privacy-blur');
                breakdownValues.forEach(el => el.classList.remove('privacy-blur'));
            }
        }

        // Auto-refresh functionality for seamless updates
        function startAutoRefresh() {
            console.log('Starting auto-refresh...');
            
            // Update values every 10 seconds for testing (will change to 30 later)
            setInterval(async function() {
                try {
                    console.log('Fetching live values...');
                    const response = await fetch('/api/live-values');
                    if (response.ok) {
                        const data = await response.json();
                        console.log('Received live data:', data);
                        
                        // Update portfolio value (only if not in privacy mode)
                        const portfolioValue = document.getElementById('portfolioValue');
                        if (portfolioValue && !privacyMode) {
                            const newValue = `£${data.current_net_worth.toLocaleString('en-GB', {minimumFractionDigits: 2, maximumFractionDigits: 2})}`;
                            if (portfolioValue.textContent !== newValue) {
                                portfolioValue.textContent = newValue;
                                console.log('Updated portfolio value to:', newValue);
                            }
                        }
                        
                        // Update last updated time
                        const lastUpdatedElement = document.querySelector('.text-gray-400.text-xs');
                        if (lastUpdatedElement && data.last_updated) {
                            const newTime = `Last updated ${data.last_updated}`;
                            if (lastUpdatedElement.textContent !== newTime) {
                                lastUpdatedElement.textContent = newTime;
                                console.log('Updated last updated time to:', newTime);
                            }
                        }
                        
                        // Update breakdown values
                        const breakdownElements = document.querySelectorAll('.breakdown-value');
                        const platformNames = Object.keys(data.platform_allocations);
                        breakdownElements.forEach((element, index) => {
                            const platformName = platformNames[index];
                            if (platformName && data.platform_allocations[platformName] && !privacyMode) {
                                const newValue = `£${data.platform_allocations[platformName].toLocaleString('en-GB', {minimumFractionDigits: 2, maximumFractionDigits: 2})}`;
                                if (element.textContent !== newValue) {
                                    element.textContent = newValue;
                                    console.log(`Updated ${platformName} value to:`, newValue);
                                }
                            }
                        });
                        
                    } else {
                        console.error('Failed to fetch live values:', response.status);
                    }
                } catch (error) {
                    console.error('Auto-refresh error:', error);
                }
            }, 10000); // Update every 10 seconds for testing
        }
        
        // Auto-refresh chart data for mobile
        function startChartAutoRefresh() {
            console.log('Starting mobile chart auto-refresh...');
            
            setInterval(function() {
                if (currentRange) {
                    console.log('Auto-refreshing mobile chart data for range:', currentRange);
                    
                    // Map mobile filters to API filters for auto-refresh
                    let apiFilter;
                    if (currentRange.toLowerCase() === 'max') {
                        apiFilter = 'all-years';
                    } else if (currentRange === '1d') {
                        apiFilter = '24h';
                    } else if (currentRange === '1w') {
                        apiFilter = 'week';
                    } else if (currentRange === '3m') {
                        apiFilter = '3months';
                    } else if (currentRange === '1y') {
                        apiFilter = 'year';
                    } else {
                        apiFilter = currentRange; // 2023, 2024, 2025
                    }
                    
                    const apiUrl = `/api/realtime-chart-data?filter=${apiFilter}`;
                        
                    fetch(apiUrl)
                        .then(response => response.json())
                        .then(data => {
                            console.log('Auto-refresh: Mobile chart data received for', currentRange);
                            updateMobileChartDisplay(data, currentRange);
                        })
                        .catch(error => {
                            console.error('Auto-refresh: Error fetching mobile chart data:', error);
                        });
                }
            }, 30000); // Refresh chart every 30 seconds
        }
    </script>
</body>
</html>

{% block scripts %}
<script>
// Mobile Chart Implementation
document.addEventListener('DOMContentLoaded', function() {
    // Mobile-optimized chart
    const mobileCtx = document.getElementById('mobileNetWorthChart').getContext('2d');
    
    // Simplified chart for mobile
    fetch('/api/chart-data')
        .then(response => response.json())
        .then(data => {
            document.getElementById('mobileChartLoading').style.display = 'none';
            
            new Chart(mobileCtx, {
                type: 'line',
                data: {
                    labels: data.labels.slice(-12), // Last 12 months only
                    datasets: [{
                        label: 'Net Worth',
                        data: data.values.slice(-12),
                        borderColor: '#3b82f6',
                        backgroundColor: 'rgba(59, 130, 246, 0.1)',
                        borderWidth: 3,
                        fill: true,
                        tension: 0.4,
                        pointRadius: 4,
                        pointBackgroundColor: '#3b82f6',
                        pointBorderColor: '#ffffff',
                        pointBorderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        intersect: false,
                        mode: 'none'
                    },

                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            enabled: false
                        }
                    },
                    scales: {
                        x: {
                            display: true,
                            grid: {
                                color: 'rgba(255, 255, 255, 0.1)'
                            },
                            ticks: {
                                color: '#9ca3af',
                                maxTicksLimit: 6
                            }
                        },
                        y: {
                            display: true,
                            grid: {
                                color: 'rgba(255, 255, 255, 0.1)'
                            },
                            ticks: {
                                color: '#9ca3af',
                                callback: function(value) {
                                    return '£' + (value / 1000).toFixed(0) + 'k';
                                }
                            }
                        }
                    }
                }
            });
        })
        .catch(error => {
            console.error('Error loading mobile chart:', error);
            document.getElementById('mobileChartLoading').innerHTML = 
                '<p class="text-red-400 text-sm">Error loading chart</p>';
        });
});

// Mobile-specific interactions
function showSettings() {
    alert('Settings functionality coming soon!');
}

// Touch-friendly interactions
document.addEventListener('touchstart', function() {}, true);
</script>
{% endblock %}