<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Portfolio - Net Worth Tracker</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- PWA and mobile icons -->
    <link rel="manifest" href="/manifest.webmanifest">
    <link rel="apple-touch-icon" href="/static/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/static/apple-touch-icon.png">
    
    <!-- iOS PWA Configuration -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Portfolio">
    <meta name="mobile-web-app-capable" content="yes">
    
    <!-- Additional PWA Meta Tags -->
    <meta name="theme-color" content="#000000">
    <meta name="msapplication-navbutton-color" content="#000000">
    
    <style>
        body {
            background: #000000;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            /* iOS Safe Area support for standalone mode */
            padding-top: env(safe-area-inset-top);
            padding-bottom: env(safe-area-inset-bottom);
        }
        
        /* Status bar handling for iOS standalone mode */
        @supports (padding-top: env(safe-area-inset-top)) {
            body {
                padding-top: env(safe-area-inset-top);
            }
        }
        
        .trading-card {
            background: rgba(20, 20, 20, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
        }
        
        .bottom-nav {
            background: rgba(10, 10, 10, 0.95);
            backdrop-filter: blur(20px);
            border-top: 1px solid rgba(255, 255, 255, 0.05);
        }
        
        /* Mobile navigation styles */
        .mobile-nav-item {
            transition: all 0.3s ease;
        }
        
        .mobile-nav-item.active {
            background: rgba(59, 130, 246, 0.2);
            border-radius: 12px;
        }
        
        .mobile-nav-item.active i {
            color: #3b82f6;
        }

        /* Privacy mode styles */
        .privacy-blur {
            filter: blur(8px);
            transition: filter 0.3s ease;
        }
        

    </style>
</head>
<body class="bg-black text-white min-h-screen" style="background: #000000 !important;">
    
    <!-- Main Content -->
    <div class="pb-24">
        <!-- Header -->
        <div class="flex items-center justify-between p-4">
            <div>
                <h1 class="text-white text-lg font-semibold">Portfolio</h1>
            </div>
        </div>
        
        <!-- Portfolio Value -->
        <div class="px-4 mb-6">
            <div class="mb-2 flex items-center justify-between">
                <span id="portfolioValue" class="text-3xl font-bold text-white">£{{ "{:,.2f}".format(current_net_worth) }}</span>
                <button onclick="togglePrivacy()" class="ml-3 p-2 rounded-full bg-gray-800/50 hover:bg-gray-700/50 transition-colors">
                    <i id="privacyIcon" class="fas fa-eye text-gray-400 text-lg"></i>
                </button>
            </div>
            
            <!-- Last Updated Info -->
            <div class="mb-4">
                <span class="text-gray-400 text-xs">Last updated {{ last_updated.strftime('%d/%m/%Y %H:%M') if last_updated else 'Never' }}</span>
            </div>
            
            <!-- Monthly and Yearly Stats -->
            <div class="flex space-x-8 mb-2">
                <div>
                    <span class="text-gray-400 text-xs uppercase tracking-wide">MONTHLY</span>
                    <div class="flex items-center space-x-1">
                        <span class="text-{% if mom_change >= 0 %}green{% else %}red{% endif %}-400 font-semibold text-sm">
                            {% if mom_change >= 0 %}+{% endif %}£{{ "{:,.0f}".format(mom_amount_change) }}
                        </span>
                        <span class="text-{% if mom_change >= 0 %}green{% else %}red{% endif %}-400 text-xs">
                            ({% if mom_change >= 0 %}+{% endif %}{{ "{:.1f}".format(mom_change) }}%)
                        </span>
                    </div>
                </div>
                <div>
                    <span class="text-gray-400 text-xs uppercase tracking-wide">YEARLY</span>
                    <div class="flex items-center space-x-1">
                        <span class="text-{% if yoy_amount_change >= 0 %}green{% else %}red{% endif %}-400 font-semibold text-sm">
                            {% if yoy_amount_change >= 0 %}+{% endif %}£{{ "{:,.0f}".format(yoy_amount_change) }}
                        </span>
                        <span class="text-{% if yoy_amount_change >= 0 %}green{% else %}red{% endif %}-400 text-xs">
                            ({% if yoy_amount_change >= 0 %}+{% endif %}{{ "{:.1f}".format(yoy_percentage_change) }}%)
                        </span>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Full Width Chart -->
        <div class="mb-6">
            <div id="chartContainer" class="h-64 w-full relative">
                <svg viewBox="0 0 400 256" class="w-full h-full" id="portfolioChart">
                    <!-- Chart elements will be dynamically updated -->
                </svg>
                
                <!-- Interactive overlay for touch/hover - aligned with chart data points -->
                <div id="chartOverlay" class="absolute inset-0 bg-transparent" 
                     ontouchstart="handleChartTouch(event)" 
                     ontouchmove="handleChartTouch(event)"
                     ontouchend="hideTooltip()"></div>
                
                <!-- Touch indicator removed - just tooltip now -->
                
                <!-- Mobile value tooltip -->
                <div id="mobileTooltip" class="absolute pointer-events-none opacity-0 transition-opacity duration-200 bg-black bg-opacity-90 text-white text-sm px-3 py-2 rounded-lg backdrop-blur-sm border border-white border-opacity-20">
                    <div id="mobileTooltipValue" class="font-semibold"></div>
                    <div id="mobileTooltipDate" class="text-gray-300 text-xs mt-1"></div>
                </div>
            </div>
            
            <!-- Time Range Options -->
            <div class="flex justify-center space-x-4 mt-3 px-4 text-xs">
                <span class="text-white font-semibold cursor-pointer" onclick="updateChart('1d')">1D</span>
                <span class="text-gray-400 cursor-pointer hover:text-white transition-colors" onclick="updateChart('1w')">1W</span>
                <span class="text-gray-400 cursor-pointer hover:text-white transition-colors" onclick="updateChart('1m')">1M</span>
                <span class="text-gray-400 cursor-pointer hover:text-white transition-colors" onclick="updateChart('3m')">3M</span>
                <span class="text-gray-400 cursor-pointer hover:text-white transition-colors" onclick="updateChart('1y')">1Y</span>
                <span class="text-gray-400 cursor-pointer hover:text-white transition-colors" onclick="updateChart('2023')">2023</span>
                <span class="text-gray-400 cursor-pointer hover:text-white transition-colors" onclick="updateChart('2024')">2024</span>
                <span class="text-gray-400 cursor-pointer hover:text-white transition-colors" onclick="updateChart('2025')">2025</span>
                <span class="text-gray-400 cursor-pointer hover:text-white transition-colors" onclick="updateChart('MAX')" id="activeRange">MAX</span>
            </div>
        </div>
        
        <!-- Section Tabs -->
        <div class="px-4 mb-4">
            <div class="flex">
                <button class="flex-1 py-3 text-center text-white border-b-2 border-blue-400">
                    <span class="font-medium">Net Worth Breakdown</span>
                </button>
            </div>
        </div>
        

        
        <!-- Investment List -->
        <div class="px-4 space-y-3">
            {% for platform, amount in platform_allocations.items() %}
            <div class="flex items-center justify-between py-3 breakdown-item" data-platform="{{ platform }}">
                <div class="flex items-center space-x-3">
                    <!-- Platform Icon -->
                    <div class="w-3 h-3 rounded-full" 
                         style="background-color: {{ platform_colors[platform] }}">
                    </div>
                    
                    <!-- Platform Info -->
                    <div>
                        <div class="text-white font-medium">{{ platform }}</div>
                        <div class="text-gray-400 text-sm">{{ "{:.1f}".format(platform_percentages.get(platform, 0)) }}% of portfolio</div>
                    </div>
                </div>
                
                <!-- Value and Change -->
                <div class="text-right">
                    <div class="text-white font-semibold breakdown-value">£{{ "{:,.2f}".format(amount) }}</div>
                    {% set platform_change = platform_monthly_changes.get(platform, {'amount': 0, 'percent': 0}) %}
                    <div class="text-{% if platform_change.amount >= 0 %}green{% else %}red{% endif %}-400 text-sm">
                        {% if platform_change.amount >= 0 %}+{% endif %}£{{ "{:,.0f}".format(platform_change.amount) }} ({% if platform_change.percent >= 0 %}+{% endif %}{{ "{:.1f}".format(platform_change.percent) }}%)
                    </div>
                </div>
            </div>
            {% endfor %}
        </div>
    </div>
    
    <!-- Mobile Bottom Navigation -->
    <div class="fixed bottom-0 left-0 right-0 z-50" style="background: rgba(0, 0, 0, 0.95); backdrop-filter: blur(20px); border-top: 1px solid rgba(255, 255, 255, 0.05);">
        <div class="flex justify-around items-center py-3 px-2">
            <!-- Home (Active) -->
            <a href="{{ url_for('mobile_dashboard') }}" 
               class="mobile-nav-item flex flex-col items-center justify-center p-3 w-16 h-16 active" style="background: rgba(59, 130, 246, 0.2); border-radius: 12px;">
                <i class="fas fa-home text-lg mb-1 text-blue-400"></i>
                <span class="text-xs text-blue-400">Home</span>
            </a>
            
            <!-- Investment Manager -->
            <a href="{{ url_for('mobile_investments') }}" 
               class="mobile-nav-item flex flex-col items-center justify-center p-3 w-16 h-16">
                <i class="fas fa-chart-line text-lg mb-1 text-gray-400"></i>
                <span class="text-xs text-gray-400">Investments</span>
            </a>
            
            <!-- Year Month Tracker -->
            <a href="{{ url_for('mobile_tracker') }}" 
               class="mobile-nav-item flex flex-col items-center justify-center p-3 w-16 h-16">
                <i class="fas fa-calendar-alt text-lg mb-1 text-gray-400"></i>
                <span class="text-xs text-gray-400">Tracker</span>
            </a>
            
            <!-- Goals -->
            <a href="{{ url_for('mobile_goals') }}" 
               class="mobile-nav-item flex flex-col items-center justify-center p-3 w-16 h-16">
                <i class="fas fa-bullseye text-lg mb-1 text-gray-400"></i>
                <span class="text-xs text-gray-400">Goals</span>
            </a>
            
            <!-- Monthly Breakdown -->
            <a href="{{ url_for('mobile_monthly') }}" 
               class="mobile-nav-item flex flex-col items-center justify-center p-3 w-16 h-16">
                <i class="fas fa-chart-pie text-lg mb-1 text-gray-400"></i>
                <span class="text-xs text-gray-400">Monthly</span>
            </a>
        </div>
    </div>
    
    <script>
        // Use real chart data from server
        const chartData = {{ chart_data | tojson | safe }};

        let currentRange = 'MAX';
        let currentChartData = null;
        let isInteracting = false;

        function updateChart(range) {
            console.log('Mobile updateChart called with range:', range, 'current:', currentRange);
            if (range === currentRange) return;
            
            // Update active range styling first
            document.querySelectorAll('[onclick^="updateChart"]').forEach(el => {
                el.className = 'text-gray-400 cursor-pointer hover:text-white transition-colors';
            });
            
            // Find and highlight the selected range
            const allRangeElements = document.querySelectorAll('[onclick^="updateChart"]');
            allRangeElements.forEach(el => {
                const onclick = el.getAttribute('onclick');
                const elRange = onclick.match(/updateChart\('(.+?)'\)/)?.[1];
                if (elRange === range) {
                    el.className = 'text-white font-semibold cursor-pointer';
                }
            });
            
            currentRange = range;
            
            // Map mobile filters to API filters
            let apiFilter;
            if (range.toLowerCase() === 'max') {
                apiFilter = 'all-years';
            } else if (range === '1d') {
                apiFilter = '24h';
            } else if (range === '1w') {
                apiFilter = 'week';
            } else if (range === '1m') {
                apiFilter = '1m';
            } else if (range === '3m') {
                apiFilter = '3months';
            } else if (range === '1y') {
                apiFilter = 'year';
            } else {
                apiFilter = range; // 2023, 2024, 2025
            }
            
            const apiUrl = `/api/realtime-chart-data?filter=${apiFilter}`;
            console.log('Fetching mobile chart data from:', apiUrl, 'for range:', range);
            
            fetch(apiUrl)
                .then(response => response.json())
                .then(data => {
                    console.log('Mobile chart data received:', data);
                    updateMobileChartDisplay(data, range);
                })
                .catch(error => {
                    console.error('Error fetching mobile chart data:', error);
                    // Fallback to static data
                    const svg = document.getElementById('portfolioChart');
                    const staticData = chartData[range];
                    if (staticData) {
                        updateMobileChartDisplay(staticData, range);
                    }
                });
        }
        
        function updateMobileChartDisplay(data, range) {
            const svg = document.getElementById('portfolioChart');
            
            console.log('Updating mobile chart display for range:', range);
            console.log('Chart data:', data);
            
            // Handle both API data format and static data format
            let lineData, yLabels, xLabels, hasCurrentValue;
            
            if (data.labels && data.values) {
                // API format - convert to SVG chart format
                console.log('Converting API data to SVG chart format');
                console.log('Data labels:', data.labels);
                console.log('Data values:', data.values);
                
                // Generate SVG chart elements from API data (balanced padding for labels)
                const chartWidth = 380;
                const chartHeight = 200;
                const padding = 20;
                const rightPadding = 35; // Balanced space for right-side labels
                const plotWidth = chartWidth - padding - rightPadding;
                const plotHeight = chartHeight - padding * 2;
                
                // Find min and max values for scaling
                const minValue = Math.min(...data.values);
                const maxValue = Math.max(...data.values);
                const valueRange = maxValue - minValue;
                
                // Generate chart points
                const points = data.values.map((value, index) => {
                    const x = padding + (index / (data.values.length - 1)) * plotWidth;
                    const y = padding + plotHeight - ((value - minValue) / valueRange) * plotHeight;
                    return `${x},${y}`;
                }).join(' ');
                
                // Generate data point circles
                const dataPoints = data.values.map((value, index) => {
                    const x = padding + (index / (data.values.length - 1)) * plotWidth;
                    const y = padding + plotHeight - ((value - minValue) / valueRange) * plotHeight;
                    return `<circle cx="${x}" cy="${y}" r="3" fill="#00d4ff" stroke="#1a1a1a" stroke-width="1"/>`;
                }).join('');
                
                // Generate Y-axis labels (properly positioned on right side)
                const yLabels = [];
                for (let i = 0; i <= 4; i++) {
                    const value = minValue + (valueRange * i / 4);
                    const y = padding + plotHeight - (i / 4) * plotHeight;
                    yLabels.push(`<text x="370" y="${y + 4}" font-size="11" fill="#9ca3af" text-anchor="start">£${(value / 1000).toFixed(0)}k</text>`);
                }
                
                // Generate X-axis labels - show all months for yearly data, otherwise smart spacing
                const xLabels = [];
                if (range === '2023' || range === '2024' || range === '2025') {
                    // Show all months for yearly views
                    for (let i = 0; i < data.labels.length; i++) {
                        const x = padding + (i / (data.labels.length - 1)) * plotWidth;
                        // Extract month from label (e.g., "Jan 25" -> "Jan")
                        const monthLabel = data.labels[i].split(' ')[0];
                        xLabels.push(`<text x="${x}" y="240" font-size="9" fill="#6b7280" text-anchor="middle">${monthLabel}</text>`);
                    }
                } else {
                    // Smart spacing for other views
                    const labelStep = Math.ceil(data.labels.length / 6); // Show ~6 labels max
                    for (let i = 0; i < data.labels.length; i += labelStep) {
                        const x = padding + (i / (data.labels.length - 1)) * plotWidth;
                        xLabels.push(`<text x="${x}" y="240" font-size="10" fill="#6b7280" text-anchor="middle">${data.labels[i]}</text>`);
                    }
                }
                
                // Mark current value point only for live/current data (not historical years)
                let currentPointMarkup = '';
                if (range !== '2023' && range !== '2024') {
                    // Only show "current" indicator for live data ranges
                    const lastIndex = data.values.length - 1;
                    const lastX = padding + (lastIndex / (data.values.length - 1)) * plotWidth;
                    const lastY = padding + plotHeight - ((data.values[lastIndex] - minValue) / valueRange) * plotHeight;
                    currentPointMarkup = `<circle cx="${lastX}" cy="${lastY}" r="5" fill="#00d4ff" stroke="#ffffff" stroke-width="2"/>`;
                }
                
                svg.innerHTML = `
                    <polyline fill="none" stroke="#00d4ff" stroke-width="2" points="${points}"/>
                    ${dataPoints}
                    ${currentPointMarkup}
                    ${yLabels.join('')}
                    ${xLabels.join('')}
                `;
                
                // Store chart data for potential interactions
                currentRange = range;
                currentChartData = {
                    values: data.values,
                    labels: data.labels,
                    points: points,
                    hasCurrentValue: true
                };
                
                console.log('Mobile SVG chart generated successfully');
                
                // Store chart data for touch interactions - using exact same positioning as chart generation
                window.mobileChartData = {
                    values: data.values,
                    labels: data.labels,
                    dataPoints: data.values.map((value, index) => {
                        // Use identical positioning logic as chart generation
                        const x = padding + (index / (data.values.length - 1)) * plotWidth;
                        const y = padding + plotHeight - ((value - minValue) / valueRange) * plotHeight;
                        return { x, y, value, label: data.labels[index] };
                    }),
                    minValue: minValue,
                    maxValue: maxValue,
                    valueRange: valueRange,
                    padding: padding,
                    plotWidth: plotWidth,
                    plotHeight: plotHeight
                };
                
                return;
            } else if (data.line) {
                // Static format - use directly
                lineData = data.line;
                yLabels = data.yLabels;
                xLabels = data.xLabels;
                hasCurrentValue = data.hasCurrentValue;
            } else {
                console.warn('No chart data for range:', range);
                svg.innerHTML = '<text x="200" y="120" text-anchor="middle" fill="#666" font-size="14">No data available</text>';
                return;
            }
            
            // Update chart  
            const chartHasCurrentValue = hasCurrentValue || false;
            const linePoints = lineData.split(' ');
            const lastPoint = linePoints[linePoints.length - 1];
            
            // Create dots for each data point
            const dataPoints = linePoints.map(point => {
                const [x, y] = point.split(',');
                return `<circle cx="${x}" cy="${y}" r="3" fill="#00d4ff" stroke="#1a1a1a" stroke-width="1"/>`;
            }).join('');
            
            // Mark current value point differently if it exists
            const currentPointMarkup = chartHasCurrentValue && lastPoint ? 
                `<circle cx="${lastPoint.split(',')[0]}" cy="${lastPoint.split(',')[1]}" r="5" fill="#00d4ff" stroke="#ffffff" stroke-width="2"/>` : '';
            
            svg.innerHTML = `
                <polyline fill="none" stroke="#00d4ff" stroke-width="2" points="${lineData}"/>
                ${dataPoints}
                ${currentPointMarkup}
                ${yLabels.map(label => 
                    `<text x="385" y="${label.y}" font-size="11" fill="#9ca3af" text-anchor="end">${label.text}</text>`
                ).join('')}
                ${xLabels.map(label => 
                    `<text x="${label.x}" y="240" font-size="10" fill="${label.text.includes('*') ? '#00d4ff' : '#6b7280'}" text-anchor="middle">${label.text}</text>`
                ).join('')}
            `;
            
            currentRange = range;
            currentChartData = {
                line: lineData,
                yLabels: yLabels,
                xLabels: xLabels,
                hasCurrentValue: chartHasCurrentValue
            };
            
            // Store actual data points for precise hover detection
            const points = lineData.split(' ').map((point, index) => {
                const [x, y] = point.split(',').map(Number);
                return {
                    x: x,
                    y: y,
                    label: xLabels[index]?.text || '',
                    index: index
                };
            });
            currentChartData.dataPoints = points;
            
            // setupChartInteraction(); // Disabled - no hover interactions
        }

        // Mobile touch interaction functions
        function handleChartTouch(event) {
            if (!window.mobileChartData) return;
            
            event.preventDefault();
            const touch = event.touches[0] || event.changedTouches[0];
            if (!touch) return;
            
            const chartContainer = document.querySelector('.relative');
            const rect = chartContainer.getBoundingClientRect();
            const touchX = touch.clientX - rect.left;
            const touchY = touch.clientY - rect.top;
            
            // Find closest data point based primarily on horizontal position (x-axis)
            let closestPoint = null;
            let minXDistance = Infinity;
            
            window.mobileChartData.dataPoints.forEach(point => {
                const xDistance = Math.abs(touchX - point.x);
                if (xDistance < minXDistance && xDistance < 50) { // 50px horizontal tolerance
                    minXDistance = xDistance;
                    closestPoint = point;
                }
            });
            
            if (closestPoint) {
                showMobileTooltip(closestPoint, touchX, touchY);
            } else {
                hideTooltip();
            }
        }
        
        function showMobileTooltip(point, touchX, touchY) {
            const tooltip = document.getElementById('mobileTooltip');
            const valueEl = document.getElementById('mobileTooltipValue');
            const dateEl = document.getElementById('mobileTooltipDate');
            
            // Update tooltip content
            valueEl.textContent = `£${point.value.toLocaleString('en-GB', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
            dateEl.textContent = point.label;
            
            // Position tooltip above the data point
            let tooltipX = point.x - 50; // Center on data point x
            let tooltipY = point.y - 80; // Position well above data point
            
            // Keep tooltip within bounds
            if (tooltipX < 10) tooltipX = 10;
            if (tooltipX > 280) tooltipX = 280;
            if (tooltipY < 10) tooltipY = point.y + 30; // Move below data point if too high
            
            tooltip.style.left = tooltipX + 'px';
            tooltip.style.top = tooltipY + 'px';
            tooltip.style.opacity = '1';
            
            // Auto-hide after 3 seconds
            clearTimeout(window.tooltipHideTimer);
            window.tooltipHideTimer = setTimeout(hideTooltip, 3000);
        }
        
        function hideTooltip() {
            const tooltip = document.getElementById('mobileTooltip');
            
            tooltip.style.opacity = '0';
            
            clearTimeout(window.tooltipHideTimer);
        }

        // Initialize chart on page load with MAX view
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Chart data:', chartData);
            
            // Force 1D view to be active on load (like desktop)
            currentRange = '';
            updateChart('1d');
            
            // Touch behaviors disabled - no chart interactions
            
            // Start auto-refresh for live updates (portfolio values)
            startAutoRefresh();
            
            // Auto-refresh chart data every 30 seconds for real-time updates
            startChartAutoRefresh();
        });

        // Privacy toggle functionality
        let privacyMode = false;

        function togglePrivacy() {
            privacyMode = !privacyMode;
            const icon = document.getElementById('privacyIcon');
            const portfolioValue = document.getElementById('portfolioValue');
            const chartContainer = document.getElementById('chartContainer');
            const breakdownValues = document.querySelectorAll('.breakdown-value');

            if (privacyMode) {
                // Enable privacy mode
                icon.className = 'fas fa-eye-slash text-blue-400 text-lg';
                portfolioValue.classList.add('privacy-blur');
                chartContainer.classList.add('privacy-blur');
                breakdownValues.forEach(el => el.classList.add('privacy-blur'));
            } else {
                // Disable privacy mode
                icon.className = 'fas fa-eye text-gray-400 text-lg';
                portfolioValue.classList.remove('privacy-blur');
                chartContainer.classList.remove('privacy-blur');
                breakdownValues.forEach(el => el.classList.remove('privacy-blur'));
            }
        }

        // Auto-refresh functionality for seamless updates
        function startAutoRefresh() {
            console.log('Starting mobile auto-refresh...');
            
            setInterval(async function() {
                try {
                    console.log('Fetching live values for mobile...');
                    const response = await fetch('/api/live-values');
                    if (response.ok) {
                        const data = await response.json();
                        console.log('Received mobile live data:', data);
                        
                        let hasChanges = false;
                        
                        // 1. Update portfolio value with animation check (only if not in privacy mode)
                        const portfolioValue = document.getElementById('portfolioValue');
                        if (portfolioValue && !privacyMode) {
                            const currentText = portfolioValue.textContent;
                            const currentValue = parseFloat(currentText.replace(/[£,]/g, ''));
                            const newValue = data.current_net_worth;
                            
                            const change = Math.abs(currentValue - newValue);
                            if (change > 0.01) { // Only animate if there's a meaningful change
                                const displayValue = `£${newValue.toLocaleString('en-GB', {minimumFractionDigits: 2, maximumFractionDigits: 2})}`;
                                portfolioValue.textContent = displayValue;
                                hasChanges = true;
                                console.log('✨ Mobile animation triggered! Updated portfolio value to:', displayValue);
                            }
                        }
                        
                        // 2. Always update Month-on-Month and Yearly values (coordinated updates)
                        const statCards = document.querySelectorAll('.bg-gray-800\\/50');
                        statCards.forEach(card => {
                            const titleElement = card.querySelector('.text-gray-400.text-xs.font-medium.uppercase.tracking-wide');
                            if (titleElement) {
                                const valueElement = card.querySelector('.text-xl.font-semibold, .text-2xl.font-bold');
                                
                                if (titleElement.textContent.includes('Month-on-Month')) {
                                    if (valueElement) {
                                        const amountSign = data.mom_amount_change >= 0 ? '+' : '';
                                        const percentSign = data.mom_change >= 0 ? '+' : '';
                                        const newText = `${amountSign}£${Math.abs(data.mom_amount_change).toLocaleString('en-GB', {minimumFractionDigits: 0, maximumFractionDigits: 0})} (${percentSign}${data.mom_change.toFixed(1)}%)`;
                                        
                                        // Always update - force coordination
                                        valueElement.textContent = newText;
                                        // Update color based on sign
                                        valueElement.className = valueElement.className.replace(/text-(green|red)-400/g, '');
                                        valueElement.className += data.mom_change >= 0 ? ' text-green-400' : ' text-red-400';
                                        
                                        if (hasChanges) {
                                            console.log('Updated mobile Month-on-Month values (coordinated)');
                                        }
                                    }
                                }
                                
                                if (titleElement.textContent.includes('Yearly Increase')) {
                                    if (valueElement) {
                                        const amountSign = data.yearly_amount_change >= 0 ? '+' : '';
                                        const percentSign = data.yearly_increase >= 0 ? '+' : '';
                                        const newText = `${amountSign}£${Math.abs(data.yearly_amount_change).toLocaleString('en-GB', {minimumFractionDigits: 0, maximumFractionDigits: 0})} (${percentSign}${data.yearly_increase.toFixed(1)}%)`;
                                        
                                        // Always update - force coordination
                                        valueElement.textContent = newText;
                                        // Update color based on sign
                                        valueElement.className = valueElement.className.replace(/text-(green|red|gray)-400/g, '');
                                        if (data.yearly_increase > 0) {
                                            valueElement.className += ' text-green-400';
                                        } else if (data.yearly_increase < 0) {
                                            valueElement.className += ' text-red-400';
                                        } else {
                                            valueElement.className += ' text-gray-400';
                                        }
                                        
                                        if (hasChanges) {
                                            console.log('Updated mobile Yearly Increase values (coordinated)');
                                        }
                                    }
                                }
                            }
                        });
                        
                        // Only update platform components when main net worth changes
                        if (hasChanges) {
                                }
                            });

                            // 3. Update breakdown values with percentages and monthly changes
                            const breakdownItems = document.querySelectorAll('.breakdown-item[data-platform]');
                            breakdownItems.forEach((item) => {
                                const platformName = item.getAttribute('data-platform');
                                if (platformName && data.platform_allocations[platformName] !== undefined) {
                                    
                                    // Update platform amount
                                    const valueElement = item.querySelector('.breakdown-value');
                                    if (valueElement && !privacyMode) {
                                        const newValue = `£${data.platform_allocations[platformName].toLocaleString('en-GB', {minimumFractionDigits: 2, maximumFractionDigits: 2})}`;
                                        if (valueElement.textContent !== newValue) {
                                            valueElement.textContent = newValue;
                                        }
                                    }
                                    
                                    // Update percentage
                                    const percentElement = item.querySelector('.text-gray-500.text-xs');
                                    if (percentElement && data.platform_percentages[platformName] !== undefined) {
                                        const newPercent = `${data.platform_percentages[platformName].toFixed(1)}%`;
                                        if (percentElement.textContent !== newPercent) {
                                            percentElement.textContent = newPercent;
                                        }
                                    }
                                    
                                    // Update monthly change indicator if present
                                    if (data.platform_monthly_changes[platformName]) {
                                        const changeData = data.platform_monthly_changes[platformName];
                                        const changeElement = item.querySelector('.text-green-500, .text-red-500, .text-gray-500');
                                        if (changeElement && changeData.previous > 0) {
                                            const changeAmount = changeData.amount;
                                            const changePercent = changeData.percent;
                                            
                                            let changeText, changeClass;
                                            if (changeAmount > 0) {
                                                changeText = `▲ +£${Math.abs(changeAmount).toLocaleString('en-GB', {minimumFractionDigits: 0, maximumFractionDigits: 0})} (+${changePercent.toFixed(1)}%)`;
                                                changeClass = 'text-green-500 text-xs font-medium';
                                            } else if (changeAmount < 0) {
                                                changeText = `▼ -£${Math.abs(changeAmount).toLocaleString('en-GB', {minimumFractionDigits: 0, maximumFractionDigits: 0})} (${changePercent.toFixed(1)}%)`;
                                                changeClass = 'text-red-500 text-xs font-medium';
                                            } else {
                                                changeText = `━ No change`;
                                                changeClass = 'text-gray-500 text-xs';
                                            }
                                            
                                            changeElement.textContent = changeText;
                                            changeElement.className = changeClass;
                                        }
                                    }
                                }
                            });

                            // 4. Update financial target progress (if present on mobile)
                            if (data.progress_info) {
                                const progressInfo = data.progress_info;
                                
                                // Update progress elements if they exist
                                const progressNetWorthElement = document.querySelector('#mobile-progress-current-net-worth');
                                if (progressNetWorthElement) {
                                    const newValue = `£${data.current_net_worth.toLocaleString('en-GB', {minimumFractionDigits: 0, maximumFractionDigits: 0})}`;
                                    if (progressNetWorthElement.textContent !== newValue) {
                                        progressNetWorthElement.textContent = newValue;
                                    }
                                }
                                
                                const progressBarElement = document.querySelector('#mobile-progress-bar');
                                const progressPercentElement = document.querySelector('#mobile-progress-percent');
                                if (progressBarElement && progressPercentElement) {
                                    const newPercent = progressInfo.progress_percentage.toFixed(1);
                                    progressBarElement.style.width = `${Math.min(progressInfo.progress_percentage, 100)}%`;
                                    progressPercentElement.textContent = `${newPercent}%`;
                                }
                                
                                const remainingAmountElement = document.querySelector('#mobile-remaining-amount');
                                if (remainingAmountElement) {
                                    const newRemaining = `£${progressInfo.remaining_amount.toLocaleString('en-GB', {minimumFractionDigits: 0, maximumFractionDigits: 0})}`;
                                    if (remainingAmountElement.textContent !== newRemaining) {
                                        remainingAmountElement.textContent = newRemaining;
                                    }
                                }
                            }
                        }
                        
                        // Always update last updated time
                        const lastUpdatedElement = document.querySelector('.text-gray-400.text-xs');
                        if (lastUpdatedElement && data.last_updated) {
                            const newTime = `Last updated ${data.last_updated}`;
                            if (lastUpdatedElement.textContent !== newTime) {
                                lastUpdatedElement.textContent = newTime;
                                console.log('Updated mobile last updated time to:', newTime);
                            }
                        }
                        
                    } else {
                        console.error('Failed to fetch mobile live values:', response.status);
                    }
                } catch (error) {
                    console.error('Mobile auto-refresh error:', error);
                }
            }, 30000); // Update every 30 seconds to match desktop
        }
        
        // Auto-refresh chart data for mobile
        function startChartAutoRefresh() {
            console.log('Starting mobile chart auto-refresh...');
            
            setInterval(function() {
                if (currentRange) {
                    console.log('Auto-refreshing mobile chart data for range:', currentRange);
                    
                    // Map mobile filters to API filters for auto-refresh
                    let apiFilter;
                    if (currentRange.toLowerCase() === 'max') {
                        apiFilter = 'all-years';
                    } else if (currentRange === '1d') {
                        apiFilter = '24h';
                    } else if (currentRange === '1w') {
                        apiFilter = 'week';
                    } else if (currentRange === '1m') {
                        apiFilter = '1m';
                    } else if (currentRange === '3m') {
                        apiFilter = '3months';
                    } else if (currentRange === '1y') {
                        apiFilter = 'year';
                    } else {
                        apiFilter = currentRange; // 2023, 2024, 2025
                    }
                    
                    const apiUrl = `/api/realtime-chart-data?filter=${apiFilter}`;
                        
                    fetch(apiUrl)
                        .then(response => response.json())
                        .then(data => {
                            console.log('Auto-refresh: Mobile chart data received for', currentRange);
                            updateMobileChartDisplay(data, currentRange);
                        })
                        .catch(error => {
                            console.error('Auto-refresh: Error fetching mobile chart data:', error);
                        });
                }
            }, 30000); // Refresh chart every 30 seconds
        }
    </script>
</body>
</html>

{% block scripts %}
<script>
// Mobile Chart Implementation
document.addEventListener('DOMContentLoaded', function() {
    // Mobile-optimized chart
    const mobileCtx = document.getElementById('mobileNetWorthChart').getContext('2d');
    
    // Simplified chart for mobile
    fetch('/api/chart-data')
        .then(response => response.json())
        .then(data => {
            document.getElementById('mobileChartLoading').style.display = 'none';
            
            new Chart(mobileCtx, {
                type: 'line',
                data: {
                    labels: data.labels.slice(-12), // Last 12 months only
                    datasets: [{
                        label: 'Net Worth',
                        data: data.values.slice(-12),
                        borderColor: '#3b82f6',
                        backgroundColor: 'rgba(59, 130, 246, 0.1)',
                        borderWidth: 3,
                        fill: true,
                        tension: 0.4,
                        pointRadius: 4,
                        pointBackgroundColor: '#3b82f6',
                        pointBorderColor: '#ffffff',
                        pointBorderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        intersect: false,
                        mode: 'none'
                    },

                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            enabled: false
                        }
                    },
                    scales: {
                        x: {
                            display: true,
                            grid: {
                                color: 'rgba(255, 255, 255, 0.1)'
                            },
                            ticks: {
                                color: '#9ca3af',
                                maxTicksLimit: 6
                            }
                        },
                        y: {
                            display: true,
                            grid: {
                                color: 'rgba(255, 255, 255, 0.1)'
                            },
                            ticks: {
                                color: '#9ca3af',
                                callback: function(value) {
                                    return '£' + (value / 1000).toFixed(0) + 'k';
                                }
                            }
                        }
                    }
                }
            });
        })
        .catch(error => {
            console.error('Error loading mobile chart:', error);
            document.getElementById('mobileChartLoading').innerHTML = 
                '<p class="text-red-400 text-sm">Error loading chart</p>';
        });
});

// Mobile-specific interactions
function showSettings() {
    alert('Settings functionality coming soon!');
}

// Touch-friendly interactions
document.addEventListener('touchstart', function() {}, true);
</script>
{% endblock %}